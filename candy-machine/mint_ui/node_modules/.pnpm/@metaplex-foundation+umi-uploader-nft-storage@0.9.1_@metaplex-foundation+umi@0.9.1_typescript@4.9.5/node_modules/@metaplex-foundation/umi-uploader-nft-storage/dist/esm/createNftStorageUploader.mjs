import { isKeypairSigner, publicKeyBytes, lamports, getBytesFromGenericFiles, createGenericFileFromJson } from '@metaplex-foundation/umi';
import { NFTStorageMetaplexor } from '@nftstorage/metaplex-auth';
import { MemoryBlockStore } from 'ipfs-car/blockstore/memory';
import { NFTStorage, Blob } from 'nft.storage';
import { toGatewayUri, toIpfsUri, toDagPbLink, toDirectoryBlock, toEncodedCar } from './utils.mjs';

/* eslint-disable no-await-in-loop */
function createNftStorageUploader(context, options = {
  token: ''
}) {
  const {
    payer
  } = options;
  const {
    token
  } = options;
  const {
    endpoint
  } = options;
  const {
    gatewayHost
  } = options;
  const batchSize = options.batchSize ?? 50;
  const useGatewayUrls = options.useGatewayUrls ?? true;
  if (!token) {
    throw new Error('NFT Storage token is required');
  }
  const getClient = async () => {
    if (token) {
      return new NFTStorage({
        token,
        endpoint
      });
    }
    const signer = payer ?? context.payer;
    const authOptions = {
      mintingAgent: '@metaplex-foundation/umi-plugin-nft-storage',
      solanaCluster: context.rpc.getCluster(),
      endpoint
    };
    return isKeypairSigner(signer) ? NFTStorageMetaplexor.withSecretKey(signer.secretKey, authOptions) : NFTStorageMetaplexor.withSigner(signer.signMessage.bind(signer), publicKeyBytes(signer.publicKey), authOptions);
  };
  const getUploadPrice = async () => lamports(0);
  const upload = async (files, options = {}) => {
    if (batchSize <= 0) {
      throw new Error('batchSize must be greater than 0');
    }
    const client = await getClient();
    const blockstore = new MemoryBlockStore();
    const uris = [];
    const numBatches = Math.ceil(files.length / batchSize);
    const batches = new Array(numBatches).fill([]).map((_, i) => files.slice(i * batchSize, (i + 1) * batchSize));
    for (let i = 0; i < batches.length; i += 1) {
      const batch = batches[i];
      const batchLinks = [];
      for (let j = 0; j < batch.length; j += 1) {
        const file = batch[j];
        const blob = new Blob([file.buffer]);
        const node = await NFTStorage.encodeBlob(blob, {
          blockstore
        });
        const fileUri = useGatewayUrls ? toGatewayUri(node.cid.toString(), undefined, gatewayHost) : toIpfsUri(node.cid.toString());
        uris.push(fileUri);
        batchLinks.push(await toDagPbLink(node, file.uniqueName));
      }
      const batchBlock = await toDirectoryBlock(batchLinks);
      const {
        cid,
        car
      } = await toEncodedCar(batchBlock, blockstore);
      const storeOptions = {};
      if (options.onProgress) {
        const {
          onProgress
        } = options;
        const totalSize = getBytesFromGenericFiles(...files);
        let uploadedSize = 0;
        storeOptions.onStoredChunk = size => {
          uploadedSize += size;
          const percent = uploadedSize / totalSize * 100;
          onProgress(Math.min(percent, 100), size);
        };
      }
      const promise = isNFTStorageMetaplexor(client) ? client.storeCar(cid, car, storeOptions) : client.storeCar(car, storeOptions);
      await promise;
    }
    return uris;
  };
  const uploadJson = async json => {
    const file = createGenericFileFromJson(json);
    const uris = await upload([file]);
    return uris[0];
  };
  return {
    getUploadPrice,
    upload,
    uploadJson,
    client: getClient
  };
}
const isNFTStorageMetaplexor = client => 'storeNFTFromFilesystem' in client;

export { createNftStorageUploader };
//# sourceMappingURL=createNftStorageUploader.mjs.map
