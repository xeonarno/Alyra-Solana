'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var umi = require('@metaplex-foundation/umi');
var metaplexAuth = require('@nftstorage/metaplex-auth');
var memory = require('ipfs-car/blockstore/memory');
var nft_storage = require('nft.storage');
var utils = require('./utils.cjs');

/* eslint-disable no-await-in-loop */
function createNftStorageUploader(context, options = {
  token: ''
}) {
  const {
    payer
  } = options;
  const {
    token
  } = options;
  const {
    endpoint
  } = options;
  const {
    gatewayHost
  } = options;
  const batchSize = options.batchSize ?? 50;
  const useGatewayUrls = options.useGatewayUrls ?? true;
  if (!token) {
    throw new Error('NFT Storage token is required');
  }
  const getClient = async () => {
    if (token) {
      return new nft_storage.NFTStorage({
        token,
        endpoint
      });
    }
    const signer = payer ?? context.payer;
    const authOptions = {
      mintingAgent: '@metaplex-foundation/umi-plugin-nft-storage',
      solanaCluster: context.rpc.getCluster(),
      endpoint
    };
    return umi.isKeypairSigner(signer) ? metaplexAuth.NFTStorageMetaplexor.withSecretKey(signer.secretKey, authOptions) : metaplexAuth.NFTStorageMetaplexor.withSigner(signer.signMessage.bind(signer), umi.publicKeyBytes(signer.publicKey), authOptions);
  };
  const getUploadPrice = async () => umi.lamports(0);
  const upload = async (files, options = {}) => {
    if (batchSize <= 0) {
      throw new Error('batchSize must be greater than 0');
    }
    const client = await getClient();
    const blockstore = new memory.MemoryBlockStore();
    const uris = [];
    const numBatches = Math.ceil(files.length / batchSize);
    const batches = new Array(numBatches).fill([]).map((_, i) => files.slice(i * batchSize, (i + 1) * batchSize));
    for (let i = 0; i < batches.length; i += 1) {
      const batch = batches[i];
      const batchLinks = [];
      for (let j = 0; j < batch.length; j += 1) {
        const file = batch[j];
        const blob = new nft_storage.Blob([file.buffer]);
        const node = await nft_storage.NFTStorage.encodeBlob(blob, {
          blockstore
        });
        const fileUri = useGatewayUrls ? utils.toGatewayUri(node.cid.toString(), undefined, gatewayHost) : utils.toIpfsUri(node.cid.toString());
        uris.push(fileUri);
        batchLinks.push(await utils.toDagPbLink(node, file.uniqueName));
      }
      const batchBlock = await utils.toDirectoryBlock(batchLinks);
      const {
        cid,
        car
      } = await utils.toEncodedCar(batchBlock, blockstore);
      const storeOptions = {};
      if (options.onProgress) {
        const {
          onProgress
        } = options;
        const totalSize = umi.getBytesFromGenericFiles(...files);
        let uploadedSize = 0;
        storeOptions.onStoredChunk = size => {
          uploadedSize += size;
          const percent = uploadedSize / totalSize * 100;
          onProgress(Math.min(percent, 100), size);
        };
      }
      const promise = isNFTStorageMetaplexor(client) ? client.storeCar(cid, car, storeOptions) : client.storeCar(car, storeOptions);
      await promise;
    }
    return uris;
  };
  const uploadJson = async json => {
    const file = umi.createGenericFileFromJson(json);
    const uris = await upload([file]);
    return uris[0];
  };
  return {
    getUploadPrice,
    upload,
    uploadJson,
    client: getClient
  };
}
const isNFTStorageMetaplexor = client => 'storeNFTFromFilesystem' in client;

exports.createNftStorageUploader = createNftStorageUploader;
//# sourceMappingURL=createNftStorageUploader.cjs.map
